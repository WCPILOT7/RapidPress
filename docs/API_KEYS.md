# API Keys

Эта система позволяет программно обращаться к API без cookie-сессий, используя заголовок `x-api-key`.

## Возможности
- Генерация ключа (однократно возвращается raw значение)
- Листинг активных ключей (без raw)
- Отзыв ключа
- Аутентификация через заголовок `x-api-key` (ключи revoked игнорируются)
- Авто‑обновление `lastUsedAt`
- Логирование использования (usage_events) привязывается к пользователю вне зависимости от способа аутентификации

## Формат ключа
```
rk_<base64url 32 байта>
```
Хранится только SHA-256 хэш. Raw ключ не восстанавливается — сохраните его сразу после создания.

## Эндпоинты
### Создать ключ
`POST /api/api-keys`
Body (опционально):
```json
{ "name": "CI Key" }
```
Response:
```json
{ "id": 12, "name": "CI Key", "createdAt": "2025-09-15T...", "key": "rk_..." }
```

### Список ключей
`GET /api/api-keys`
Response (пример):
```json
[
  { "id": 12, "name": "CI Key", "createdAt": "2025-09-15T...", "lastUsedAt": null, "revoked": false }
]
```

### Отозвать ключ
`POST /api/api-keys/:id/revoke`
Response:
```json
{ "success": true }
```

## Аутентификация
Для вызова защищённых маршрутов без сессии:
```
GET /api/generate
x-api-key: rk_...
```
Если ключ валиден и не отозван — `req.user` заполняется и проверка `requireAuth` проходит.

## Ошибки и безопасность
- Утечка raw ключа = немедленно revoke.
- Рекомендуется ограничивать ключи по quota (пока не реализовано) и добавлять rate limiting.
- В будущем: скоупы (scopes) и префиксный поиск ключей.

## План расширения
1. Привязка лимитов (дневные токены, RPS)
2. Scopes (ограничить доступ к подмножеству эндпоинтов)
3. Персонализированные billing события
4. Агрегация usage по ключу (отдельные отчёты)

## FAQ
**Q:** Можно ли восстановить потерянный ключ?  
**A:** Нет. Создайте новый и отзовите старый если он скомпрометирован.

**Q:** Что если передан недействительный ключ?  
**A:** Аутентификация не устанавливается, маршрут вернёт 401 при наличии `requireAuth`.

---
Обновлено: 2025-09-15
